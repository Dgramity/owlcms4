package app.owlcms.ui.shared;

import java.time.LocalDate;
import java.util.Optional;

import org.slf4j.LoggerFactory;
import org.vaadin.crudui.crud.CrudOperation;

import com.vaadin.flow.component.HasValue;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.data.binder.Binder;
import com.vaadin.flow.data.binder.Binder.Binding;
import com.vaadin.flow.data.binder.Binder.BindingBuilder;
import com.vaadin.flow.data.binder.Validator;
import com.vaadin.flow.data.provider.ListDataProvider;
import com.vaadin.flow.data.validator.DoubleRangeValidator;

import app.owlcms.components.fields.BodyWeightField;
import app.owlcms.components.fields.LocalDateField;
import app.owlcms.data.athlete.Athlete;
import app.owlcms.data.athlete.Gender;
import app.owlcms.data.category.Category;
import app.owlcms.data.category.CategoryRepository;
import app.owlcms.init.OwlcmsSession;
import app.owlcms.ui.crudui.OwlcmsCrudFormFactory;
import app.owlcms.utils.LoggerUtils;
import ch.qos.logback.classic.Logger;

@SuppressWarnings("serial")
public final class AthleteRegistrationFormFactory extends OwlcmsCrudFormFactory<Athlete> {
	final private static Logger logger = (Logger)LoggerFactory.getLogger(AthleteRegistrationFormFactory.class);
	
	private Athlete editedAthlete = null;
	private boolean genderCatOk = false;
	private boolean catGenderOk = false;

	public AthleteRegistrationFormFactory(Class<Athlete> domainType) {
		super(domainType);
	}

	/**
	 * Add bean-level validations
	 * @see org.vaadin.crudui.form.AbstractAutoGeneratedCrudFormFactory#buildBinder(org.vaadin.crudui.crud.CrudOperation, java.lang.Object)
	 */
	@Override
	protected Binder<Athlete> buildBinder(CrudOperation operation, Athlete domainObject) {
		editedAthlete  = domainObject;
		binder = super.buildBinder(operation, domainObject);
		//binder.withValidator(ValidationUtils.checkUsing((a) -> a.validateStartingTotalsRule(), ""));
		updateErrorLabelFromBeanValidationErrors(true);
		return binder;
	}

	/** 
	 * Change the caption to show the current athlete name and group
	 * 
	 * @see
	 * org.vaadin.crudui.form.impl.form.factory.DefaultCrudFormFactory#buildCaption(org.vaadin.crudui.
	 * crudGrid.CrudOperation, java.lang.Object) 
	 */
	@Override
	public String buildCaption(CrudOperation operation, Athlete a) {
		if (a.getLastName() == null && a.getFirstName() == null)
			return null;
		// If null, CrudLayout.showForm will build its own, for backward compatibility
		return a.getFullId();
	}

	/**
	 * Add the field-level validations
	 * @see org.vaadin.crudui.form.AbstractAutoGeneratedCrudFormFactory#bindField(com.vaadin.flow.component.HasValue, java.lang.String, java.lang.Class)
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	@Override
	protected void bindField(HasValue field, String property, Class<?> propertyType) {
		Binder.BindingBuilder bindingBuilder = binder.forField(field);
		
		if ("bodyWeight".equals(property)) {
			bodyWeightValidation(bindingBuilder, ((BodyWeightField) field).isRequired());
			bindingBuilder.bind(property);
		} else if ("fullBirthDate".equals(property)) {
			fullBirthDateValidation(bindingBuilder);
			HasValue<?, ?> bdateField = bindingBuilder.getField();
			bdateField.addValueChangeListener((e) -> {
				LocalDate date = (LocalDate) e.getValue();
				HasValue<?, ?> genderField = binder.getBinding("gender").get().getField();
				Optional<Binding<Athlete, ?>> magBinding = binder.getBinding("mastersAgeGroup");
				if (magBinding.isPresent()) {
					HasValue<?, String> ageGroupField = (HasValue<?, String>) magBinding.get().getField();
					Gender gender = (Gender) genderField.getValue();
					if (gender != null && date != null) {
						int year = date.getYear();
						ageGroupField.setValue(editedAthlete.getMastersAgeGroup(gender.name(),year));
					} else {
						ageGroupField.setValue(null);
					}
				}
			});
			bindingBuilder.bind(property);
		} else if ("category".equals(property)) {
			categoryValidation(bindingBuilder);
			//filterCategories(bindingBuilder);
			bindingBuilder.bind(property);
		} else if ("gender".equals(property)) {
			genderValidation(bindingBuilder);
			HasValue<?, ?> genderField = bindingBuilder.getField();
			genderField.addValueChangeListener((e) -> {
				Gender gender = (Gender) e.getValue();
				Optional<Binding<Athlete, ?>> fbdBinding = binder.getBinding("fullBirthDate");
				HasValue<?, LocalDate> dateField = (HasValue<?, LocalDate>) fbdBinding.get().getField();
				Optional<Binding<Athlete, ?>> agBinding = binder.getBinding("mastersAgeGroup");
				if (agBinding.isPresent()) {
					HasValue<?, String> ageGroupField = (HasValue<?, String>) agBinding.get().getField();
					LocalDate date = dateField.getValue();
					if (gender != null && date != null) {
						int year = date.getYear();
						ageGroupField.setValue(editedAthlete.getMastersAgeGroup(gender.name(),year));
					} else {
						ageGroupField.setValue("");
					}
				}
			});
			bindingBuilder.bind(property);
		} else if (property.endsWith("Declaration")) {
			TextField declField = (TextField)bindingBuilder.getField();
			declField.setPattern("^(-?\\d+)|()$"); // optional minus and at least one digit, or empty.
			declField.setPreventInvalidInput(true);
			bindingBuilder.bind(property);
		} else {
			super.bindField(field, property, propertyType);
		}
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void fullBirthDateValidation(Binder.BindingBuilder bindingBuilder) {
		LocalDateField ldtf = (LocalDateField) bindingBuilder.getField();
		Validator<LocalDate> fv = ldtf.formatValidation(OwlcmsSession.getLocale());
		bindingBuilder.withValidator(fv);

		Validator<LocalDate> v = Validator.from(
			ld -> {
				if (ld == null)
					return true;
				return ld.compareTo(LocalDate.now()) <= 0;
			},
			"Birth date cannot be in the future");
		bindingBuilder.withValidator(v);
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void bodyWeightValidation(Binder.BindingBuilder bindingBuilder, boolean isRequired) {
		Validator<Double> v1 = new DoubleRangeValidator(
				"Weight should be between 0 and 350kg", 0.0D, 350.0D);
		// check wrt body category
		Validator<Double> v2 = Validator.from((weight) -> {
				if (!isRequired && weight == null)
					return true;
				// inconsistent selection is signaled on the category dropdown since the weight is a factual
				// measure
				Binding<Athlete, ?> categoryBinding = binder.getBinding("category").get();
				categoryBinding.validate(true).isError();
				return true;
			}, "Body Weight is outside of selected category");
		bindingBuilder.withValidator(v1);
		bindingBuilder.withValidator(v2);
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void categoryValidation(Binder.BindingBuilder bindingBuilder) {
		
		// check that category is consistent with body weight
		Validator<Category> v1 = Validator.from((category) -> {
			if (category == null) return true;
			try {
				Binding<Athlete, ?> bwBinding = binder.getBinding("bodyWeight").get();
				Double bw = (Double) bwBinding.getField().getValue();
				if (bw == null)
					// no body weight - no contradiction
					return true;
				Double min = category.getMinimumWeight();
				Double max = category.getMaximumWeight();
				logger.trace(
					"comparing {} ]{},{}] with body weight {}", category.getName(), min, max, bw);
				return (bw > min && bw <= max);
			} catch (Exception e) {
				logger.error(LoggerUtils.stackTrace(e));
			}
			return true;
		},
			"Category does not match body weight");
		bindingBuilder.withValidator(v1);

		// check that category is consistent with gender
		Validator<Category> v2 = Validator.from((category) -> {
			try {
				if (category == null) return true;
				Binding<Athlete, ?> genderBinding = binder.getBinding("gender").get();
				ComboBox<Gender> genderCombo = (ComboBox<Gender>) genderBinding.getField();
				Gender g = (Gender) genderCombo.getValue();
				Gender catGender = category != null ? category.getGender() : null;
				logger.debug("categoryValidation: validating gender {} vs category {}: {}",g,catGender,catGender == g);
				if (g == null) {
					// no gender - no contradiction
					return true;
				}
				catGenderOk = catGender == g;
				if (catGenderOk && !genderCatOk) {
					// validate() does not validate if no change, ugly workaround
					logger.debug("resetting gender");
					genderCombo.setValue(null);
					genderCombo.setValue(g); // turn off message if present.
				}
				return catGender == g;
			} catch (Exception e) {
				logger.error(LoggerUtils.stackTrace(e));
			}
			return true;
		},
			"Category does not match gender.");
		bindingBuilder.withValidator(v2);
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void genderValidation(Binder.BindingBuilder bindingBuilder) {
		// check that category is consistent with gender
		Validator<Gender> v2 = Validator.from((g) -> {
			try {
				if (g == null) return true;
				Binding<Athlete, ?> catBinding = binder.getBinding("category").get();
				ComboBox<Category> categoryCombo = (ComboBox<Category>) catBinding.getField();
				Category category = (Category) categoryCombo.getValue();
				logger.debug("genderValidation: validating gender {} vs category {}: {}",g,category.getGender(),category.getGender() == g);
				genderCatOk = category.getGender() == g;
				if (genderCatOk && !catGenderOk) {
					 // turn off message if present.
					logger.debug("resetting category");
					categoryCombo.setValue(null);
					categoryCombo.setValue(category);
				}
				return genderCatOk;
			} catch (Exception e) {
				logger.error(LoggerUtils.stackTrace(e));
			}
			return true;
		},
			"Category does not match gender.");
		bindingBuilder.withValidator(v2);
	}

	@SuppressWarnings({ "unchecked", "rawtypes"})
	public void filterCategories(BindingBuilder categoryBindingBuilder) {
		ComboBox<Category> categoryField = (ComboBox<Category>) categoryBindingBuilder.getField();
		Binding<Athlete, ?> genderBinding = binder.getBinding("gender").get();
		ComboBox<Gender> genderField =  (ComboBox<Gender>) genderBinding.getField();
		ListDataProvider<Category> listDataProvider = new ListDataProvider<Category>(CategoryRepository.findActive(genderField.getValue()));
		genderField.addValueChangeListener((vc) -> {categoryField.setDataProvider(listDataProvider);});
	}
}