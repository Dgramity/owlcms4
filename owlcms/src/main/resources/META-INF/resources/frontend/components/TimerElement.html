<link href="../bower_components/polymer/polymer-element.html"
	rel="import">
<link href="../bower_components/iron-icons/iron-icons.html"
	rel="import">
<link href="../bower_components/iron-icons/av-icons.html"
	rel="import">	

<dom-module id="timer-element" attributes="start-time count-up">
<template>
<style></style>
<audio id="initialWarning" preload="auto"><source src="../sounds/initialWarning.mp3"></source></audio>
<audio id="finalWarning" preload="auto"><source src="../sounds/finalWarning.mp3"></source></audio>
<audio id="timeOver" preload="auto"><source src="../sounds/timeOver.mp3"></source></audio>
<div>{{_formattedTime}}</div>
</template>
<script>
  class TimerElement extends Polymer.Element {
      static get is() {
          return 'timer-element'
      }

      static get properties() {
    	  return {
          /**
           * Start time for the timer in seconds
           * @default 60
           */
           startTime: {
             type: Number,
             reflectToAttribute: true,
             value: 60,
             observer: '_init'
           },
           /**
           * Current time of the timer, in seconds
           */
           currentTime: {
             type: Number,
             notify: true
           },
           /**
           * True if the timer is currently running
           * @default false
           */
           running: {
             type: Boolean,
             reflectToAttribute: true,
             notify: true,
             value: false
           },
           /**
           * Set to true to have timer count up
           * @default false
           */
           countUp: {
             type: Boolean,
             reflectToAttribute: true,
             value: false
           },
           /**
           * Time the timer has spent running since it was started
           */
           _lastTimerUpdateTime: {
             type: Number,
             value: 0
           },
           _formattedTime: {
             type: String,
             value: '0:00'
           },
           initialWarningGiven: {
        	   type: Boolean,
        	   value: false
           },
           finalWarningGiven: {
        	   type: Boolean,
        	   value: false
           },
           timeOverWarningGiven: {
        	   type: Boolean,
        	   value: false
           }
    	}
      }
      
      ready() {
    	  super.ready();
		  this._init();
		  document.onvisibilitychange = this._decreaseTimer.bind(this);
      }

      start() {
          if ((this.currentTime <= 0 && !this.countUp) 
              || (this.currentTime >= this.startTime && this.countUp) ) {
            // timer is over
            this.currentTime = this.countUp ? this.startTime : 0;
          }
          
          if (!this.startTime || this.running) {
            this.pause();
            return;
          }
          this.initialWarningGiven = (this.currentTime < 90);
          this.finalWarningGiven = (this.currentTime < 30);
          this.timeOverWarningGiven = (this.currentTime < 0);

          this._lastTimerUpdate = performance.now()/1000;
          this.running = true;
          window.requestAnimationFrame(this._fixTimer.bind(this));
      }

      pause() {
          this.running = false;
          if (this.$server != null) {
			  this.$server.timerStopped(this.currentTime);      
          } else {
        	  console.log("no server$");
          }
      }
      
      reset() {
    	  this.pause();
    	  this._init();
      }
      

      _init() {
          this.running = false;
          if (this.countUp) {
              this.set('currentTime', 0);
              this.set('_formattedTime', '0:00');
          } else {
              this.set('currentTime', this.startTime);
              this.set('_formattedTime', this._formatTime(this.startTime));
          }
          this.initialWarningGiven = false;
          this.finalWarningGiven = false;
          this.timeOverWarningGiven = false;
      }
      
     _decreaseTimer() {
          if (!this.running) {
            return;
          }
          
          var now = performance.now()/1000;
          // Compute the relative progress based on the time spent running
          var progress = now - this._lastTimerUpdate;
          this.currentTime = this.countUp ? this.currentTime + progress : this.currentTime - progress;
          
          // we anticipate by 0.1 sec because .play() has a perceptible delay
          if (this.currentTime <= 30.1 && !this.finalWarningGiven) {
        	  //console.warn("currentTime "+this.currentTime);
        	  this.$.finalWarning.play();
        	  this.finalWarningGiven = true;
          }
          if (this.currentTime <= 90.1 && !this.initialWarningGiven) {
        	  this.$.initialWarning.play();
        	  this.initialWarningGiven = true;
          }
          if (this.currentTime <= 0.1 && !this.timeOverWarningGiven) {
        	  console.warn("calling play "+this.currentTime);
              this.$.timeOver.play();
              this.timeOverWarningGiven = true;
          }       
          if ((this.currentTime <= 0 && !this.countUp) 
              || (this.currentTime >= this.startTime && this.countUp) ) {
				// timer is over
                if (this.$server != null) this.$server.timeOver();   
                this.running = false;
            	//this.dispatchEvent(new CustomEvent('timer-element-end', {bubbles: true, composed: true}))
            	this.currentTime = this.countUp ? this.startTime : 0; // avoid ugly if rounding error.
			}

		this._formattedTime = this._formatTime(this.currentTime);
		this._lastTimerUpdate = now;
		window.requestAnimationFrame(this._decreaseTimer.bind(this));
    }
     
	_fixTimer() {
	    if (!this.running) {
			this.$server.syncTimeRemaining();
			this._formattedTime = this._formatTime(this.currentTime);
	    }
	    return;
	 }

    _formatTime(ntime) {
    	if (ntime < 0) return "0:00";
    	var ntime = Math.round(ntime);
    	var hours = Math.trunc(ntime / 3600);
    	var minutes = Math.trunc((ntime - (hours*3600)) / 60);
    	var seconds = ntime - ((hours*3600)+(minutes*60));
    	return (hours > 0 ? hours + ":" : "")+(minutes+":"+ (seconds < 10 ? "0"+seconds : seconds));
    }
  }
  
  customElements.define(TimerElement.is, TimerElement);
  </script> </dom-module>